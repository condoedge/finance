<?php

namespace Condoedge\Finance\Models;

use App\Models\User;
use Condoedge\Finance\Events\InvoiceGenerated;
use Illuminate\Support\Facades\DB;

/**
 * Class Invoice
 * 
 * @package Condoedge\Finance\Models
 * 
 * @property int $id
 * @property InvoiceTypeEnum $invoice_type_id Foreign key to fin_invoice_types
 * @property int $invoice_number @TRIGGERED BY tr_invoice_number_before_insert -  Auto-generated by database trigger
 * @property string $invoice_reference @CALCULATED BY get_invoice_reference() - Built from invoice_type_id and invoice_number
 * @property mixed $invoice_amount_before_taxes @CALCULATED BY calculate_invoice_amount() - Total amount of the invoice (Without taxes)
 * @property float $invoice_amount @CALCULATED BY STORED GENERATED COLUMN (invoice_amount_before_taxes + invoice_tax_amount)
 * @property float $invoice_due_amount @CALCULATED BY calculate_invoice_due() - Remaining amount to be paid
 * @property float $invoice_tax_amount @CALCULATED BY calculate_invoice_tax() - Total tax amount
 * @property InvoiceStatusEnum $invoice_status_id @CALCULATED BY calculate_invoice_status()
 * @property \DateTime $invoice_date
 * @property \DateTime $invoice_due_date
 * @property PaymentTypeEnum $payment_type_id
 * @property bool $is_draft Default: true
 * @property int|null $approved_by Foreign key to users table
 * @property \DateTime|null $approved_at
 * @property int $historical_customer_id Foreign key to fin_historical_customers
 * @property int $customer_id Foreign key to fin_customers
 * 
 * @property-read string $customer_label The name of the customer
 * @property-read string $invoice_type_label The invoice type label (Invoice, Credit, etc.)
 * @property-read string $invoice_status_label The invoice status label (Draft, Paid, etc.)
 * @property-read float $abs_invoice_amount The absolute value of the invoice amount
 * @property-read string $payment_type_label The payment type label (Cash, Credit Card, etc.)
 * 
 */
class Invoice extends AbstractMainFinanceModel
{
    use \Condoedge\Utils\Models\ContactInfo\Maps\MorphManyAddresses;
    
    protected $table = 'fin_invoices';

    protected $casts = [
        'invoice_date' => 'date',
        'invoice_due_date' => 'date',
        'invoice_status_id' => InvoiceStatusEnum::class,
        'invoice_type_id' => InvoiceTypeEnum::class,
        'payment_type_id' => PaymentTypeEnum::class,
        'approved_at' => 'datetime',
    ];

    public function save(array $options = [])
    {
        return parent::save($options);
    }

    /**
     * Get the creation event class for this model.
     *
     * @return string
     */
    protected function getCreatedEventClass()
    {
        return InvoiceGenerated::class;
    }

    /* RELATIONSHIPS */
    public function customer()
    {
        return $this->belongsTo(HistoricalCustomer::class, 'historical_customer_id');
    }

    public function invoiceDetails()
    {
        return $this->hasMany(InvoiceDetail::class, 'invoice_id');
    }

    public function invoiceStatus()
    {
        return $this->belongsTo(InvoiceStatus::class, 'invoice_status_id');
    }

    public function approvedBy()
    {
        return $this->belongsTo(User::class, 'approved_by');
    }

    /* ATTRIBUTES */
    public function getCustomerLabelAttribute()
    {
        return $this->customer->name;
    }

    public function getInvoiceTypeLabelAttribute()
    {
        return $this->invoice_type_id?->label();
    }

    public function getInvoiceStatusLabelAttribute()
    {
        return $this->invoice_status_id?->label();
    }

    public function getAbsInvoiceAmountAttribute()
    {
        return abs($this->invoice_amount);
    }

    public function getPaymentTypeLabelAttribute()
    {
        return $this->payment_type_id?->label();
    }

    /* SCOPES */
    public function scopeForTeam($query, $teamId)
    {
        $query->whereHas('customer', function ($query) use ($teamId) {
            $query->where('team_id', $teamId);
        });
    }

    /* CALCULATED FIELDS */
    public function canApprove()
    {
        return $this->invoice_status_id === InvoiceStatusEnum::DRAFT;
    }

    public function isRefund()
    {
        return $this->invoice_type_id->signMultiplier() < 0;
    }

    /* ACTIONS */
    public function markApproved()
    {
        $this->is_draft = false;
        $this->approved_by = auth()->user()->id;
        $this->approved_at = now();
        $this->save();
    }

    /* ELEMENTS */
    public function approvalEls()
    {
        return _Flex2(
            $this->approvedByLabel()->icon('icon-check'),
            $this->approved_at ? _Flex2(
                _Html('finance-on-le')->class('font-bold'),
                _HtmlDate($this->approved_at),
            ) : null
        );
    }

    public function approvedByLabel()
    {
        return _Html('<b>'.__('finance-approved-by').'</b> '.$this->approvedBy->name);
    }


    /** INTEGRITY */
    public static function checkIntegrity($ids = null): void
    {
        $paidStatus = InvoiceStatusEnum::PAID->value;
        $draftStatus = InvoiceStatusEnum::DRAFT->value;
        $pendingStatus = InvoiceStatusEnum::PENDING->value;

        DB::table('fin_invoices')
            ->when($ids, function ($query) use ($ids) {
                return $query->whereIn('id', $ids);
            })
            ->update([
                'invoice_due_amount' => DB::raw('calculate_invoice_due(fin_invoices.id)'),
                'invoice_amount_before_taxes' => DB::raw('calculate_invoice_amount_before_taxes(fin_invoices.id)'),
                'invoice_tax_amount' => DB::raw('calculate_invoice_tax(fin_invoices.id)'),
                'invoice_reference' => DB::raw('get_invoice_reference(fin_invoices.id)'),
                'invoice_status_id' => DB::raw("calculate_invoice_status(fin_invoices.id, $paidStatus, $draftStatus, $pendingStatus)"),
            ]);
    }
}
