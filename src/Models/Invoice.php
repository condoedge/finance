<?php

namespace Condoedge\Finance\Models;

use App\Models\User;
use Condoedge\Finance\Billing\PaymentGatewayResolver;
use Condoedge\Finance\Casts\SafeDecimal;
use Condoedge\Finance\Casts\SafeDecimalCast;
use Condoedge\Finance\Events\InvoiceGenerated;
use Condoedge\Finance\Facades\CustomerModel;
use Condoedge\Finance\Facades\InvoiceDetailModel;
use Condoedge\Finance\Facades\InvoicePaymentModel;
use Condoedge\Finance\Facades\PaymentGateway;
use Condoedge\Finance\Facades\InvoiceService;
use Condoedge\Finance\Models\Dto\Invoices\CreateInvoiceDto;
use Condoedge\Finance\Models\Dto\Invoices\CreateOrUpdateInvoiceDetail;
use Condoedge\Finance\Models\Dto\Invoices\ApproveInvoiceDto;
use Condoedge\Finance\Models\Dto\Invoices\ApproveManyInvoicesDto;
use Condoedge\Finance\Models\Dto\Invoices\UpdateInvoiceDto;
use Condoedge\Utils\Facades\GlobalConfig;
use Illuminate\Support\Facades\DB;

/**
 * Class Invoice
 * 
 * @package Condoedge\Finance\Models
 * 
 * @property int $id
 * @property InvoiceTypeEnum $invoice_type_id Foreign key to fin_invoice_types
 * @property int $invoice_number @TRIGGERED BY tr_invoice_number_before_insert -  Auto-generated by database trigger
 * @property string $invoice_reference @CALCULATED BY get_invoice_reference() - Built from invoice_type_id and invoice_number
 * @property mixed $invoice_amount_before_taxes @CALCULATED BY calculate_invoice_amount() - Total amount of the invoice (Without taxes)
 * @property \Condoedge\Finance\Casts\SafeDecimal $invoice_total_amount @CALCULATED BY STORED GENERATED COLUMN (invoice_amount_before_taxes + invoice_tax_amount)
 * @property \Condoedge\Finance\Casts\SafeDecimal $invoice_due_amount @CALCULATED BY calculate_invoice_due() - Remaining amount to be paid
 * @property \Condoedge\Finance\Casts\SafeDecimal $invoice_tax_amount @CALCULATED BY calculate_invoice_tax() - Total tax amount
 * @property InvoiceStatusEnum $invoice_status_id @CALCULATED BY calculate_invoice_status()
 * @property \DateTime $invoice_date
 * @property \DateTime $invoice_due_date
 * @property PaymentTypeEnum $payment_type_id
 * @property bool $is_draft Default: true
 * @property int|null $approved_by Foreign key to users table
 * @property \DateTime|null $approved_at
 * @property int $historical_customer_id Foreign key to fin_historical_customers
 * @property int $customer_id Foreign key to fin_customers
 * 
 * @property-read string $customer_label The name of the customer
 * @property-read string $invoice_type_label The invoice type label (Invoice, Credit, etc.)
 * @property-read string $invoice_status_label The invoice status label (Draft, Paid, etc.)
 * @property-read SafeDecimal $abs_invoice_total_amount The absolute value of the invoice amount
 * @property-read SafeDecimal $abs_invoice_due_amount The absolute value of the invoice due amount
 * @property-read string $payment_type_label The payment type label (Cash, Credit Card, etc.)
 * 
 */
class Invoice extends AbstractMainFinanceModel
{
    use \Condoedge\Utils\Models\ContactInfo\Maps\MorphManyAddresses;
    
    protected $table = 'fin_invoices';

    protected $casts = [
        'invoice_date' => 'date',
        'invoice_due_date' => 'date',
        'invoice_status_id' => InvoiceStatusEnum::class,
        'invoice_type_id' => InvoiceTypeEnum::class,
        'payment_type_id' => PaymentTypeEnum::class,
        'approved_at' => 'datetime',
        'invoice_total_amount' => SafeDecimalCast::class,
        'invoice_due_amount' => SafeDecimalCast::class,
        'invoice_tax_amount' => SafeDecimalCast::class,
    ];

    public function save(array $options = [])
    {
        return parent::save($options);
    }

    /**
     * Get the creation event class for this model.
     *
     * @return string
     */
    protected function getCreatedEventClass()
    {
        return InvoiceGenerated::class;
    }

    /* RELATIONSHIPS */
    public function customer()
    {
        return $this->belongsTo(HistoricalCustomer::class, 'historical_customer_id');
    }

    public function invoiceDetails()
    {
        return $this->hasMany(InvoiceDetail::class, 'invoice_id');
    }

    public function invoiceDetailsTaxes()
    {
        return $this->hasManyThrough(InvoiceDetailTax::class, InvoiceDetail::class, 'invoice_id', 'invoice_detail_id');
    }

    public function invoiceStatus()
    {
        return $this->belongsTo(InvoiceStatus::class, 'invoice_status_id');
    }

    public function approvedBy()
    {
        return $this->belongsTo(User::class, 'approved_by');
    }

    public function payments()
    {
        return $this->hasMany(InvoicePaymentModel::getClass(), 'invoice_id');
    }

    /* ATTRIBUTES */
    public function getCustomerLabelAttribute()
    {
        return $this->customer->name;
    }

    public function getInvoiceTypeLabelAttribute()
    {
        return $this->invoice_type_id?->label();
    }

    public function getInvoiceStatusLabelAttribute()
    {
        return $this->invoice_status_id?->label();
    }

    public function getAbsInvoiceTotalAmountAttribute()
    {
        return $this->invoice_total_amount->abs();
    }

    public function getAbsInvoiceDueAmountAttribute()
    {
        return $this->invoice_due_amount->abs();
    }

    public function getPaymentTypeLabelAttribute()
    {
        return $this->payment_type_id?->label();
    }

    /* SCOPES */
    public function scopeForTeam($query, $teamId)
    {
        $query->whereHas('customer', function ($query) use ($teamId) {
            $query->where('team_id', $teamId);
        });
    }

    public function scopeForCustomer($query, $customerId)
    {
        return $query->where('customer_id', $customerId);
    }

    public function scopePending($query)
    {
        return $query->where('invoice_status_id', InvoiceStatusEnum::PENDING);
    }

    public function scopeCanApplyOnIt($query)
    {
        return $query->pending()->where('invoice_type_id', InvoiceTypeEnum::INVOICE);
    }

    public function scopeByReferenceDetails($query, $prefix, $number)
    {
        $type = collect(InvoiceTypeEnum::cases())->first(function ($case) use ($prefix) {
            return $case->prefix() === $prefix;
        });

        return $query->where('invoice_number', $number)
            ->where('invoice_type_id', $type?->value);
    }

    /* CALCULATED FIELDS */
    public function canApprove()
    {
        return $this->invoice_status_id === InvoiceStatusEnum::DRAFT;
    }

    public function isRefund()
    {
        return $this->invoice_type_id->signMultiplier() < 0;
    }

    public function canBePaid()
    {
        return $this->invoice_status_id->canBePaid();
    }

    public function getTaxesGrouped()
    {
        return $this->invoiceDetailsTaxes()->groupBy('tax_id')->groupBy('invoice_id')
                ->selectRaw('SUM(fin_invoice_detail_taxes.tax_amount) as tax_amount, tax_id')->with('tax')->get();
    }

    public function getVisualTaxesGrouped()
    {
        return $this->getTaxesGrouped()->mapWithKeys(function ($item) {
            return [$item->tax->name => $item->tax_amount];
        });
    }

    /* ACTIONS */
    public function markApproved()
    {
        $this->is_draft = false;
        $this->approved_by = auth()->user()->id;
        $this->approved_at = now();
        $this->save();
    }

    /* 
     * STATIC METHODS - These now delegate to InvoiceService
     * 
     * ARCHITECTURE NOTE: These static methods are maintained for backward compatibility.
     * New code should use InvoiceService facade directly for better testability and flexibility.
     * 
     * Example of recommended usage:
     *   InvoiceService::createInvoice($dto) instead of Invoice::createInvoiceFromDto($dto)
     */

    /**
     * Create invoice from DTO
     * 
     * @deprecated Use InvoiceService::createInvoice() instead for better architecture
     */
    public static function createInvoiceFromDto(CreateInvoiceDto $dto): self
    {
        return InvoiceService::createInvoice($dto);
    }

    /**
     * Update invoice from DTO
     * 
     * @deprecated Use InvoiceService::updateInvoice() instead for better architecture
     */
    public static function updateInvoiceFromDto(UpdateInvoiceDto $dto): self
    {
        return InvoiceService::updateInvoice($dto);
    }

    /**
     * Approve single invoice
     * 
     * @deprecated Use InvoiceService::approveInvoice() instead for better architecture
     */
    public static function approveInvoice(ApproveInvoiceDto $data): self
    {
        return InvoiceService::approveInvoice($data);
    }

    /**
     * Approve multiple invoices
     * 
     * @deprecated Use InvoiceService::approveMany() instead for better architecture
     */
    public function approveManyInvoices(ApproveManyInvoicesDto $data)
    {
        return InvoiceService::approveMany($data);
    }

    /**
     * Get default taxes IDs for this invoice
     * 
     * @deprecated Use InvoiceService::getDefaultTaxesIds() instead for better architecture
     */
    public function getDefaultTaxesIds()
    {
        return InvoiceService::getDefaultTaxesIds($this);
    }

    /* ELEMENTS */
    public function approvalEls()
    {
        return _Flex2(
            $this->approvedByLabel()->icon('icon-check'),
            $this->approved_at ? _Flex2(
                _Html('finance-on-le')->class('font-bold'),
                _HtmlDate($this->approved_at),
            ) : null
        );
    }

    public function approvedByLabel()
    {
        return _Html('<b>'.__('finance-approved-by').'</b> '.$this->approvedBy->name);
    }


    /** INTEGRITY */
    public static function columnsIntegrityCalculations()
    {
        return [
            'invoice_due_amount' => DB::raw('calculate_invoice_due(fin_invoices.id)'),
            'invoice_amount_before_taxes' => DB::raw('calculate_invoice_amount_before_taxes(fin_invoices.id)'),
            'invoice_tax_amount' => DB::raw('calculate_invoice_tax(fin_invoices.id)'),
            'invoice_reference' => DB::raw('get_invoice_reference(fin_invoices.id)'),
            'invoice_status_id' => DB::raw("calculate_invoice_status(fin_invoices.id, ".InvoiceStatusEnum::PAID->value.", ".InvoiceStatusEnum::DRAFT->value.", ".InvoiceStatusEnum::PENDING->value.")"),
        ];
    }
}
