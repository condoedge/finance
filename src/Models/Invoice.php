<?php

namespace Condoedge\Finance\Models;

use App\Models\User;
use Carbon\Carbon;
use Condoedge\Finance\Billing\Contracts\FinancialPayableInterface;
use Condoedge\Finance\Casts\SafeDecimal;
use Condoedge\Finance\Casts\SafeDecimalCast;
use Condoedge\Finance\Events\InvoiceGenerated;
use Condoedge\Finance\Facades\InvoicePaymentModel;
use Condoedge\Finance\Facades\InvoiceService;
use Condoedge\Finance\Facades\PaymentService;
use Condoedge\Finance\Models\Dto\Invoices\ApproveInvoiceDto;
use Condoedge\Finance\Models\Dto\Payments\CreateApplyForInvoiceDto;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Support\Collection as SupportCollection;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Kompo\Auth\Models\Teams\Team;

/**
 * Class Invoice
 *
 * @package Condoedge\Finance\Models
 *
 * @property int $id
 * @property InvoiceTypeEnum $invoice_type_id Foreign key to fin_invoice_types
 * @property int $invoice_number @TRIGGERED BY tr_invoice_number_before_insert -  Auto-generated by database trigger
 * @property string $invoice_reference @CALCULATED BY get_invoice_reference() - Built from invoice_type_id and invoice_number
 * @property mixed $invoice_amount_before_taxes @CALCULATED BY calculate_invoice_amount() - Total amount of the invoice (Without taxes)
 * @property \Condoedge\Finance\Casts\SafeDecimal $invoice_total_amount @CALCULATED BY STORED GENERATED COLUMN (invoice_amount_before_taxes + invoice_tax_amount)
 * @property \Condoedge\Finance\Casts\SafeDecimal $invoice_due_amount @CALCULATED BY calculate_invoice_due() - Remaining amount to be paid
 * @property \Condoedge\Finance\Casts\SafeDecimal $invoice_tax_amount @CALCULATED BY calculate_invoice_tax() - Total tax amount
 * @property InvoiceStatusEnum $invoice_status_id @CALCULATED BY calculate_invoice_status()
 * @property Carbon $invoice_date
 * @property Carbon $invoice_due_date
 * @property PaymentMethodEnum $payment_method_id
 * @property bool $is_draft Default: true
 * @property int|null $approved_by Foreign key to users table
 * @property Carbon|null $approved_at
 * @property int $historical_customer_id Foreign key to fin_historical_customers
 * @property int $customer_id Foreign key to fin_customers
 * @property string $invoiceable_type The type of the invoiceable model (it could have information about what the client is paying)
 * @property int $invoiceable_id The id of the invoiceable model (it could have information about what the client is paying)
 * @property int $payment_term_id The payment installment type (One-time, Monthly, etc.)
 * @property PaymentTerm $paymentTerm The payment installment model associated with the invoice
 * @property PaymentMethodEnum $payment_method The payment method type (Cash, Credit Card, etc.)
 * @property int[] $possible_payment_terms An array with the ids of available installments in the current invoice
 * @property int[] $possible_payment_methods An array with the ids of available payment methods in the current invoice
 * @property int $account_receivable_id
 * @property-read string $customer_label The name of the customer
 * @property-read string $invoice_type_label The invoice type label (Invoice, Credit, etc.)
 * @property-read string $invoice_status_label The invoice status label (Draft, Paid, etc.)
 * @property-read SafeDecimal $abs_invoice_total_amount The absolute value of the invoice amount
 * @property-read SafeDecimal $abs_invoice_due_amount The absolute value of the invoice due amount
 * @property-read string $payment_method_label The payment type label (Cash, Credit Card, etc.)
 * @property-read InvoiceableInterface $invoiceable The invoiceable model associated with the invoice
 *
 * Relationships:
 * @property Customer $customer The customer associated with the invoice
 * @property Collection<InvoiceDetail> $invoiceDetails The details of the invoice (items, services, etc.)
 * @property PaymentTerm $paymentTerm The payment term associated with the invoice
 * @property Collection<PaymentInstallmentPeriod> $installmentsPeriods The payment installment periods associated with the invoice
 */
class Invoice extends AbstractMainFinanceModel implements FinancialPayableInterface
{
    use \Condoedge\Utils\Models\ContactInfo\Maps\MorphManyAddresses;
    use \Condoedge\Finance\Billing\Traits\PayableTrait;
    // use \Condoedge\Utils\Models\Traits\BelongsToTeamTrait;

    protected $table = 'fin_invoices';

    protected $casts = [
        'invoice_date' => 'date',
        'invoice_due_date' => 'date',
        'invoice_status_id' => InvoiceStatusEnum::class,
        'invoice_type_id' => InvoiceTypeEnum::class,
        'payment_method_id' => PaymentMethodEnum::class,
        'approved_at' => 'datetime',
        'invoice_total_amount' => SafeDecimalCast::class,
        'invoice_due_amount' => SafeDecimalCast::class,
        'invoice_tax_amount' => SafeDecimalCast::class,

        'invoice_amount_before_taxes' => SafeDecimalCast::class,

        'possible_payment_methods' => 'array',
        'possible_payment_terms' => 'array',

        'sent_at' => 'datetime',
    ];

    /**
     * Get the creation event class for this model.
     *
     * @return string
     */
    protected function getCreatedEventClass()
    {
        return InvoiceGenerated::class;
    }

    /* RELATIONSHIPS */
    public function customer()
    {
        return $this->belongsTo(HistoricalCustomer::class, 'historical_customer_id');
    }

    public function mainCustomer()
    {
        return $this->belongsTo(Customer::class, 'customer_id');
    }

    public function team()
    {
        return $this->hasOneThrough(Team::class, HistoricalCustomer::class, 'id', 'id', 'historical_customer_id', 'team_id')
            ->throughAuthorizedRelation();
    }

    public function invoiceDetails()
    {
        return $this->hasMany(InvoiceDetail::class, 'invoice_id');
    }

    public function invoiceDetailsTaxes()
    {
        return $this->hasManyThrough(InvoiceDetailTax::class, InvoiceDetail::class, 'invoice_id', 'invoice_detail_id');
    }

    public function invoiceStatus()
    {
        return $this->belongsTo(InvoiceStatus::class, 'invoice_status_id');
    }

    public function approvedBy()
    {
        return $this->belongsTo(User::class, 'approved_by');
    }

    public function payments()
    {
        return $this->hasMany(InvoicePaymentModel::getClass(), 'invoice_id');
    }

    public function invoiceable()
    {
        return $this->morphTo();
    }

    public function accountReceivable()
    {
        return $this->belongsTo(GlAccount::class, 'account_receivable_id');
    }

    public function paymentTerm()
    {
        return $this->belongsTo(PaymentTerm::class, 'payment_term_id');
    }

    public function installmentsPeriods()
    {
        return $this->hasMany(PaymentInstallmentPeriod::class, 'invoice_id');
    }

    public function paymentTraces()
    {
        return $this->morphMany(PaymentTrace::class, 'payable');
    }

    /* ATTRIBUTES */
    public function getInvoiceTypeLabelAttribute()
    {
        return $this->invoice_type_id?->label();
    }

    public function getInvoiceStatusLabelAttribute()
    {
        return $this->invoice_status_id?->label();
    }

    public function getAbsInvoiceTotalAmountAttribute()
    {
        return $this->invoice_total_amount->abs();
    }

    public function getAbsInvoiceDueAmountAttribute()
    {
        return $this->invoice_due_amount->abs();
    }

    public function getPaymentTypeLabelAttribute()
    {
        return $this->payment_method_id?->label();
    }

    public function getCustomerLabelAttribute()
    {
        return $this->customer->name;
    }

    /* SCOPES */
    public function scopeForTeam($query, $teamId)
    {
        return $query->whereHas('customer', fn ($q) => $q->forTeam($teamId));
    }

    public function scopeForCustomer($query, $customerId)
    {
        return $query->where('customer_id', $customerId)
            ->orWhereHas('customer', function ($q) use ($customerId) {
                $q->where('customer_id', $customerId);
            });
    }

    public function scopePending($query)
    {
        return $query->where('invoice_status_id', InvoiceStatusEnum::PENDING);
    }

    public function scopeCanApplyOnIt($query)
    {
        return $query->pending()->where('invoice_type_id', InvoiceTypeEnum::INVOICE);
    }

    public function scopeByReferenceDetails($query, $prefix, $number)
    {
        $type = collect(InvoiceTypeEnum::cases())->first(function ($case) use ($prefix) {
            return $case->prefix() === $prefix;
        });

        return $query->where('invoice_number', $number)
            ->where('invoice_type_id', $type?->value);
    }

    public function scopeToBePaid($query)
    {
        return $query->whereIn('invoice_status_id', InvoiceStatusEnum::allToBePaid())
            ->whereNotNull('sent_at');
    }


    /* CALCULATED FIELDS */
    public function canApprove()
    {
        return $this->invoice_status_id === InvoiceStatusEnum::DRAFT;
    }

    public function isRefund()
    {
        return $this->invoice_type_id->signMultiplier() < 0;
    }

    public function isLate()
    {
        return $this->invoice_status_id === InvoiceStatusEnum::OVERDUE;
    }

    public function canBePaid()
    {
        return $this->invoice_status_id->canBePaid();
    }

    public function getTaxesGrouped()
    {
        return $this->invoiceDetailsTaxes()->groupBy('tax_id')->groupBy('invoice_id')
            ->selectRaw('SUM(fin_invoice_detail_taxes.tax_amount) as tax_amount, tax_id')->with('tax')->get();
    }

    public function getVisualTaxesGrouped()
    {
        return $this->getTaxesGrouped()->mapWithKeys(function ($item) {
            return [$item->tax->name => $item->tax_amount];
        });
    }

    public function hasMissingInfoToApprove()
    {
        return false;
    }

    protected function checkInvoiceable()
    {
        if ($this->invoiceable && !($this->invoiceable instanceof InvoiceableInterface)) {
            Log::critical('Invoiceable model does not implement InvoiceableInterface' . ' for invoice ID: ' . $this->id);
            return false;
        }

        return true;
    }

    public function getNextInstallmentPeriod()
    {
        return $this->installmentsPeriods()->where('due_amount', '>', 0)->first();
    }

    /* ACTIONS */
    public function markApproved()
    {
        InvoiceService::approveInvoice(new ApproveInvoiceDto([
            'invoice_id' => $this->id,
        ]));

        $this->refresh();
    }

    public function markAsSent()
    {
        $this->sent_at = now();
        $this->save();
    }

    public function sendToCustomer()
    {
        InvoiceService::sendInvoice($this->id);
    }

    /* ELEMENTS */
    public function approvalEls()
    {
        return _Flex2(
            $this->approvedByLabel()->icon('icon-check'),
            $this->approved_at ? _Flex2(
                _Html('finance-on-le')->class('font-bold'),
                _HtmlDate($this->approved_at),
            ) : null
        );
    }

    public function approvedByLabel()
    {
        return _Html('<b>' . __('finance-approved-by') . '</b> ' . $this->approvedBy->name);
    }

    public function sentEls()
    {
        if (!$this->sent_at) {
            return null;
        }

        return _Flex(
            _Html('finance-invoice-sent-at')->class('font-semibold'),
            _HtmlDate($this->sent_at)
        )->class('gap-4');
    }

    public function onCompletePayment()
    {
        if ($this->complete_payment_managed_at) {
            return;
        }
        try {
            DB::transaction(function () {

                $this->complete_payment_managed_at = now();
                $this->saveQuietly();

                if (!$this->checkInvoiceable()) {
                    return;
                }

                $this->invoiceable?->onCompletePayment();
            });
        } catch (\Exception $e) {
            Log::error('Error managing complete payment for invoice ID: ' . $this->id, [
                'error' => $e->getMessage(),
                'invoice_id' => $this->id,
                'invoice' => $this,
                'trace' => $e->getTraceAsString(),
            ]);
        }
    }

    public function onPartialPayment()
    {
        if ($this->partial_payment_managed_at) {
            return;
        }
        try {
            DB::transaction(function () {
                $this->partial_payment_managed_at = now();
                $this->saveQuietly();

                if (!$this->checkInvoiceable()) {
                    return;
                }

                $this->invoiceable?->onPartialPayment();
            });
        } catch (\Exception $e) {
            Log::error('Error managing partial payment for invoice ID: ' . $this->id, [
                'error' => $e->getMessage(),
            ]);
        }
    }

    /**
     * In some payments terms net x we need to execute a function before the first payment or when the invoice is considered as initial paid.
     */
    public function onConsideredAsInitialPaid()
    {
        if ($this->considered_as_initial_paid_at) {
            return;
        }

        try {
            DB::transaction(function () {

                $this->considered_as_initial_paid_at = now();
                $this->saveQuietly();

                if (!$this->checkInvoiceable()) {
                    return;
                }

                $this->invoiceable?->onConsideredAsInitialPaid();
            });
        } catch (\Exception $e) {
            Log::error('Error managing initial paid state for invoice ID: ' . $this->id, [
                'error' => $e->getMessage(),
            ]);
        }
    }

    public function onOverdue()
    {
        if ($this->overdue_managed_at) {
            return;
        }

        try {
            DB::transaction(function () {
                $this->overdue_managed_at = now();
                $this->saveQuietly();

                if (!$this->checkInvoiceable()) {
                    return;
                }

                $this->invoiceable?->onOverdue();
            });
        } catch (\Exception $e) {
            Log::error('Error managing overdue state for invoice ID: ' . $this->id, [
                'error' => $e->getMessage(),
            ]);
        }
    }

    public function setPrimaryBillingAddress($addressId)
    {
        return null;
    }

    public function setPrimaryShippingAddress($addressId)
    {
        return null;
    }

    // PAYMENT PROCESSORS
    public function getCustomer(): ?Customer
    {
        // The main customer instead of historical
        return Customer::findOrFail($this->customer_id);
    }

    public function onPaymentFailed(array $failureData): void
    {
        Log::error('Payment failed for invoice', [
            'invoice_id' => $this->id,
            'error' => $failureData['error'] ?? 'Unknown error',
            'transaction_id' => $failureData['transaction_id'] ?? null,
        ]);
    }

    public function onPaymentSuccess(CustomerPayment $payment): void
    {
        Log::info('Payment succeeded for invoice', [
            'invoice_id' => $this->id,
            'payment_id' => $payment->id,
        ]);

        PaymentService::applyPaymentToInvoice(new CreateApplyForInvoiceDto([
            'invoice_id' => $this->id,
            'amount_applied' => $payment->amount,
            'apply_date' => now(),
            'applicable_type' => MorphablesEnum::PAYMENT->value,
            'applicable' => (object) [
                'id' => $payment->id,
                'customer_id' => $this->customer_id,
            ],
        ]));
    }

    public function getPayableAmount(): SafeDecimal
    {
        return $this->invoice_due_amount;
    }

    public function getPayableLines(): SupportCollection
    {
        return $this->invoiceDetails->map(function ($invoiceDetail) {
            return new \Condoedge\Finance\Models\Dto\Invoices\PayableLineDto([
                'description' => $invoiceDetail->name,
                'sku' => 'id.' . $invoiceDetail->id,
                'price' => $invoiceDetail->total_amount->divide($invoiceDetail->quantity)->toFloat(),
                'quantity' => $invoiceDetail->quantity,
                'amount' => $invoiceDetail->total_amount->toFloat(),
            ]);
        });
    }

    public function getPaymentDescription(): string
    {
        return __('invoice.payment.description', ['invoice_id' => $this->id]);
    }

    public function getTeamId(): int
    {
        return $this->customer?->team_id ?? 0;
    }

    public function getCustomerName(): ?string
    {
        return $this->customer?->name;
    }

    /** INTEGRITY */
    public static function columnsIntegrityCalculations()
    {
        return [
            'invoice_due_amount' => DB::raw('calculate_invoice_due(fin_invoices.id)'),
            'invoice_amount_before_taxes' => DB::raw('calculate_invoice_amount_before_taxes(fin_invoices.id)'),
            'invoice_tax_amount' => DB::raw('calculate_invoice_tax(fin_invoices.id)'),
            'invoice_reference' => DB::raw('get_invoice_reference(fin_invoices.id)'),
            'invoice_status_id' => DB::raw("calculate_invoice_status(fin_invoices.id)"),
        ];
    }
}
