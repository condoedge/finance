<?php

namespace Condoedge\Finance\Models;

use App\Models\User;
use Condoedge\Finance\Casts\SafeDecimal;
use Condoedge\Finance\Casts\SafeDecimalCast;
use Condoedge\Finance\Events\InvoiceGenerated;
use Condoedge\Finance\Facades\InvoicePaymentModel;
use Condoedge\Finance\Facades\InvoiceService;
use Condoedge\Finance\Models\Dto\Invoices\ApproveInvoiceDto;
use Illuminate\Support\Facades\DB;

/**
 * Class Invoice
 *
 * @package Condoedge\Finance\Models
 *
 * @property int $id
 * @property InvoiceTypeEnum $invoice_type_id Foreign key to fin_invoice_types
 * @property int $invoice_number @TRIGGERED BY tr_invoice_number_before_insert -  Auto-generated by database trigger
 * @property string $invoice_reference @CALCULATED BY get_invoice_reference() - Built from invoice_type_id and invoice_number
 * @property mixed $invoice_amount_before_taxes @CALCULATED BY calculate_invoice_amount() - Total amount of the invoice (Without taxes)
 * @property \Condoedge\Finance\Casts\SafeDecimal $invoice_total_amount @CALCULATED BY STORED GENERATED COLUMN (invoice_amount_before_taxes + invoice_tax_amount)
 * @property \Condoedge\Finance\Casts\SafeDecimal $invoice_due_amount @CALCULATED BY calculate_invoice_due() - Remaining amount to be paid
 * @property \Condoedge\Finance\Casts\SafeDecimal $invoice_tax_amount @CALCULATED BY calculate_invoice_tax() - Total tax amount
 * @property InvoiceStatusEnum $invoice_status_id @CALCULATED BY calculate_invoice_status()
 * @property \DateTime $invoice_date
 * @property \DateTime $invoice_due_date
 * @property PaymentMethodEnum $payment_method_id
 * @property bool $is_draft Default: true
 * @property int|null $approved_by Foreign key to users table
 * @property \DateTime|null $approved_at
 * @property int $historical_customer_id Foreign key to fin_historical_customers
 * @property int $customer_id Foreign key to fin_customers
 * @property string $invoiceable_type The type of the invoiceable model (it could have information about what the client is paying)
 * @property int $invoiceable_id The id of the invoiceable model (it could have information about what the client is paying)
 * @property PaymentInstallmentEnum $payment_installment The payment installment type (One-time, Monthly, etc.)
 * @property PaymentMethodEnum $payment_method The payment method type (Cash, Credit Card, etc.)
 * @property int[] $possible_payment_installments An array with the ids of available installments in the current invoice
 * @property int[] $possible_payment_methods An array with the ids of available payment methods in the current invoice
 * @property int $account_receivable_id
 * @property-read string $customer_label The name of the customer
 * @property-read string $invoice_type_label The invoice type label (Invoice, Credit, etc.)
 * @property-read string $invoice_status_label The invoice status label (Draft, Paid, etc.)
 * @property-read SafeDecimal $abs_invoice_total_amount The absolute value of the invoice amount
 * @property-read SafeDecimal $abs_invoice_due_amount The absolute value of the invoice due amount
 * @property-read string $payment_method_label The payment type label (Cash, Credit Card, etc.)
 */
class Invoice extends AbstractMainFinanceModel
{
    use \Condoedge\Utils\Models\ContactInfo\Maps\MorphManyAddresses;
    use \Condoedge\Utils\Models\Traits\BelongsToTeamTrait;

    protected $table = 'fin_invoices';

    protected $casts = [
        'invoice_date' => 'date',
        'invoice_due_date' => 'date',
        'invoice_status_id' => InvoiceStatusEnum::class,
        'invoice_type_id' => InvoiceTypeEnum::class,
        'payment_method_id' => PaymentMethodEnum::class,
        'payment_installment_id' => PaymentInstallmentEnum::class,
        'approved_at' => 'datetime',
        'invoice_total_amount' => SafeDecimalCast::class,
        'invoice_due_amount' => SafeDecimalCast::class,
        'invoice_tax_amount' => SafeDecimalCast::class,

        'invoice_amount_before_taxes' => SafeDecimalCast::class,

        'possible_payment_methods' => 'array',
        'possible_payment_installments' => 'array',
    ];

    public function save(array $options = [])
    {
        return parent::save($options);
    }

    /**
     * Get the creation event class for this model.
     *
     * @return string
     */
    protected function getCreatedEventClass()
    {
        return InvoiceGenerated::class;
    }

    /* RELATIONSHIPS */
    public function customer()
    {
        return $this->belongsTo(HistoricalCustomer::class, 'historical_customer_id');
    }

    public function invoiceDetails()
    {
        return $this->hasMany(InvoiceDetail::class, 'invoice_id');
    }

    public function invoiceDetailsTaxes()
    {
        return $this->hasManyThrough(InvoiceDetailTax::class, InvoiceDetail::class, 'invoice_id', 'invoice_detail_id');
    }

    public function invoiceStatus()
    {
        return $this->belongsTo(InvoiceStatus::class, 'invoice_status_id');
    }

    public function approvedBy()
    {
        return $this->belongsTo(User::class, 'approved_by');
    }

    public function payments()
    {
        return $this->hasMany(InvoicePaymentModel::getClass(), 'invoice_id');
    }

    public function invoiceable()
    {
        return $this->morphTo();
    }

    public function accountReceivable()
    {
        return $this->belongsTo(GlAccount::class, 'account_receivable_id');
    }

    /* ATTRIBUTES */
    public function getInvoiceTypeLabelAttribute()
    {
        return $this->invoice_type_id?->label();
    }

    public function getInvoiceStatusLabelAttribute()
    {
        return $this->invoice_status_id?->label();
    }

    public function getAbsInvoiceTotalAmountAttribute()
    {
        return $this->invoice_total_amount->abs();
    }

    public function getAbsInvoiceDueAmountAttribute()
    {
        return $this->invoice_due_amount->abs();
    }

    public function getPaymentTypeLabelAttribute()
    {
        return $this->payment_method_id?->label();
    }

    public function getCustomerLabelAttribute()
    {
        return $this->customer->name;
    }

    /* SCOPES */
    public function scopeForTeam($query, $teamId)
    {
        return $query->whereHas('customer', fn ($q) => $q->forTeam($teamId));
    }

    public function scopeForCustomer($query, $customerId)
    {
        return $query->where('customer_id', $customerId)
            ->orWhereHas('customer', function ($q) use ($customerId) {
                $q->where('customer_id', $customerId);
            });
    }

    public function scopePending($query)
    {
        return $query->where('invoice_status_id', InvoiceStatusEnum::PENDING);
    }

    public function scopeCanApplyOnIt($query)
    {
        return $query->pending()->where('invoice_type_id', InvoiceTypeEnum::INVOICE);
    }

    public function scopeByReferenceDetails($query, $prefix, $number)
    {
        $type = collect(InvoiceTypeEnum::cases())->first(function ($case) use ($prefix) {
            return $case->prefix() === $prefix;
        });

        return $query->where('invoice_number', $number)
            ->where('invoice_type_id', $type?->value);
    }

    /* CALCULATED FIELDS */
    public function canApprove()
    {
        return $this->invoice_status_id === InvoiceStatusEnum::DRAFT;
    }

    public function isRefund()
    {
        return $this->invoice_type_id->signMultiplier() < 0;
    }

    public function canBePaid()
    {
        return $this->invoice_status_id->canBePaid();
    }

    public function getTaxesGrouped()
    {
        return $this->invoiceDetailsTaxes()->groupBy('tax_id')->groupBy('invoice_id')
                ->selectRaw('SUM(fin_invoice_detail_taxes.tax_amount) as tax_amount, tax_id')->with('tax')->get();
    }

    public function getVisualTaxesGrouped()
    {
        return $this->getTaxesGrouped()->mapWithKeys(function ($item) {
            return [$item->tax->name => $item->tax_amount];
        });
    }

    /* ACTIONS */
    public function markApproved()
    {
        InvoiceService::approveInvoice(new ApproveInvoiceDto([
            'invoice_id' => $this->id,
        ]));
    }

    /* ELEMENTS */
    public function approvalEls()
    {
        return _Flex2(
            $this->approvedByLabel()->icon('icon-check'),
            $this->approved_at ? _Flex2(
                _Html('finance-on-le')->class('font-bold'),
                _HtmlDate($this->approved_at),
            ) : null
        );
    }

    public function approvedByLabel()
    {
        return _Html('<b>'.__('finance-approved-by').'</b> '.$this->approvedBy->name);
    }

    public function getScheduleElement($from = null)
    {
        $date = $from ?: now();
        $installment = $this->payment_installment ?: PaymentInstallmentEnum::ONE_TIME;

        $payments = collect([]);

        for ($i = 0; $i <= $installment->getTimes() - 1; $i++) {
            $payments->push((object) [
                'date' => $i == 0 && !$from ? __('events.now') : $date->format('Y-m-d'),
                'amount' => $this->invoice_total_amount / $installment->getTimes(),
            ]);

            $date = $installment->getNextDate($date);
        }

        return _Rows(
            $payments->map(fn ($payment) => _FlexBetween(
                _Html($payment->date),
                _FinanceCurrency($payment->amount),
            ))
        )->class('gap-2');
    }


    /** INTEGRITY */
    public static function columnsIntegrityCalculations()
    {
        return [
            'invoice_due_amount' => DB::raw('calculate_invoice_due(fin_invoices.id)'),
            'invoice_amount_before_taxes' => DB::raw('calculate_invoice_amount_before_taxes(fin_invoices.id)'),
            'invoice_tax_amount' => DB::raw('calculate_invoice_tax(fin_invoices.id)'),
            'invoice_reference' => DB::raw('get_invoice_reference(fin_invoices.id)'),
            'invoice_status_id' => DB::raw("calculate_invoice_status(fin_invoices.id, ".InvoiceStatusEnum::PAID->value.", ".InvoiceStatusEnum::DRAFT->value.", ".InvoiceStatusEnum::PENDING->value.")"),
        ];
    }
}
